{"version":3,"sources":["../../src/dataProvider/index.ts","../../src/utils/index.ts","../../src/utils/graphql.ts","../../src/liveProvider/index.ts","../../src/index.ts","../../../../node_modules/graphql-request/src/index.ts"],"sourcesContent":["import { BaseRecord, DataProvider, LogicalFilter } from \"@refinedev/core\";\n\nimport camelcase from \"camelcase\";\nimport * as gql from \"gql-query-builder\";\nimport VariableOptions from \"gql-query-builder/build/VariableOptions\";\nimport { GraphQLClient } from \"graphql-request\";\nimport gqlTag from \"graphql-tag\";\nimport { singular } from \"pluralize\";\n\nimport { generateFilters, generatePaging, generateSorting } from \"../utils\";\n\nimport { getOperationFields, isMutation } from \"../utils/graphql\";\n\nconst dataProvider = (client: GraphQLClient): Required<DataProvider> => {\n    return {\n        getList: async ({ resource, pagination, sorters, filters, meta }) => {\n            const operation = camelcase(resource);\n\n            const paging = generatePaging(pagination || {});\n\n            const queryVariables: VariableOptions = {};\n\n            let query;\n            let variables;\n\n            if (meta?.gqlQuery) {\n                query = meta?.gqlQuery;\n\n                variables = {\n                    filter: filters\n                        ? generateFilters(filters as LogicalFilter[])\n                        : {},\n                    sorting: sorters ? generateSorting(sorters) : [],\n                    paging,\n                };\n            } else {\n                if (filters) {\n                    queryVariables[\"filter\"] = {\n                        type: camelcase(`${singular(resource)}Filter`, {\n                            pascalCase: true,\n                        }),\n                        required: true,\n                        value: generateFilters(filters as LogicalFilter[]),\n                    };\n                }\n\n                if (sorters) {\n                    queryVariables[\"sorting\"] = {\n                        type: camelcase(`${singular(resource)}Sort`, {\n                            pascalCase: true,\n                        }),\n                        required: true,\n                        list: [true],\n                        value: generateSorting(sorters),\n                    };\n                }\n\n                if (paging) {\n                    queryVariables[\"paging\"] = {\n                        type: \"OffsetPaging\",\n                        required: true,\n                        value: paging,\n                    };\n                }\n\n                const gqlQuery = gql.query({\n                    operation,\n                    fields: [{ nodes: meta?.fields }, \"totalCount\"],\n                    variables: queryVariables,\n                });\n\n                query = gqlQuery.query;\n                variables = gqlQuery.variables;\n            }\n\n            const response = await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: response[operation].nodes,\n                total: response[operation].totalCount,\n            };\n        },\n\n        getMany: async ({ resource, ids, meta }) => {\n            const operation = camelcase(resource);\n\n            if (meta?.gqlQuery) {\n                const response = await client.request<BaseRecord>(\n                    meta.gqlQuery,\n                    {\n                        filter: {\n                            id: { in: ids },\n                        },\n                    },\n                );\n\n                return {\n                    data: response[operation].nodes,\n                };\n            }\n\n            const { query, variables } = gql.query({\n                operation,\n                fields: [{ nodes: meta?.fields || [\"id\"] }],\n                variables: {\n                    filter: {\n                        type: camelcase(`${singular(resource)}Filter`, {\n                            pascalCase: true,\n                        }),\n                        required: true,\n                        value: {\n                            id: { in: ids },\n                        },\n                    },\n                },\n            });\n\n            const response = await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: response[operation].nodes,\n            };\n        },\n\n        create: async ({ resource, variables, meta }) => {\n            const operation = `createOne${camelcase(singular(resource), {\n                pascalCase: true,\n            })}`;\n\n            const gqlOperation = meta?.gqlMutation ?? meta?.gqlQuery;\n\n            if (gqlOperation) {\n                const response = await client.request<BaseRecord>(\n                    gqlOperation,\n                    { input: { [camelcase(singular(resource))]: variables } },\n                );\n\n                return {\n                    data: response[operation],\n                };\n            }\n\n            const { query, variables: queryVariables } = gql.mutation({\n                operation,\n                fields: meta?.fields || [\"id\"],\n                variables: {\n                    input: {\n                        type: `CreateOne${camelcase(singular(resource), {\n                            pascalCase: true,\n                        })}Input`,\n                        required: true,\n                        value: {\n                            [camelcase(singular(resource))]: variables,\n                        },\n                    },\n                },\n            });\n\n            const response = await client.request<BaseRecord>(\n                query,\n                queryVariables,\n            );\n\n            return {\n                data: response[operation],\n            };\n        },\n\n        createMany: async ({ resource, variables, meta }) => {\n            const pascalResource = camelcase(resource, { pascalCase: true });\n            const operation = `createMany${pascalResource}`;\n\n            const gqlOperation = meta?.gqlMutation ?? meta?.gqlQuery;\n\n            if (gqlOperation) {\n                const response = await client.request<BaseRecord>(\n                    gqlOperation,\n                    {\n                        input: {\n                            [camelcase(resource)]: variables,\n                        },\n                    },\n                );\n\n                return {\n                    data: response[operation],\n                };\n            }\n\n            const { query, variables: queryVariables } = gql.mutation({\n                operation,\n                fields: meta?.fields || [\"id\"],\n                variables: {\n                    input: {\n                        type: `CreateMany${camelcase(resource, {\n                            pascalCase: true,\n                        })}Input`,\n                        required: true,\n                        value: {\n                            [camelcase(resource)]: variables,\n                        },\n                    },\n                },\n            });\n\n            const response = await client.request<BaseRecord>(\n                query,\n                queryVariables,\n            );\n\n            return {\n                data: response[operation],\n            };\n        },\n        update: async ({ resource, id, variables, meta }) => {\n            const operation = `updateOne${camelcase(singular(resource), {\n                pascalCase: true,\n            })}`;\n\n            const gqlOperation = meta?.gqlMutation ?? meta?.gqlQuery;\n\n            if (gqlOperation) {\n                const response = await client.request<BaseRecord>(\n                    gqlOperation,\n                    {\n                        input: {\n                            id,\n                            update: variables,\n                        },\n                    },\n                );\n\n                return {\n                    data: response[operation],\n                };\n            }\n\n            const { query, variables: queryVariables } = gql.mutation({\n                operation,\n                fields: meta?.fields || [\"id\"],\n                variables: {\n                    input: {\n                        type: `UpdateOne${camelcase(singular(resource), {\n                            pascalCase: true,\n                        })}Input`,\n                        required: true,\n                        value: {\n                            id,\n                            update: variables,\n                        },\n                    },\n                },\n            });\n\n            const response = await client.request<BaseRecord>(\n                query,\n                queryVariables,\n            );\n\n            return {\n                data: response[operation],\n            };\n        },\n        updateMany: async ({ resource, ids, variables, meta }) => {\n            const pascalResource = camelcase(resource, {\n                pascalCase: true,\n            });\n\n            const mutationOperation = `updateMany${pascalResource}`;\n\n            const mutation = gqlTag`\n                mutation UpdateMany${pascalResource}($input: UpdateMany${pascalResource}Input!) {\n                    ${mutationOperation}(input: $input) {\n                        updatedCount\n                    }\n                }\n            `;\n\n            await client.request<BaseRecord>(mutation, {\n                input: { filter: { id: { in: ids } }, update: variables },\n            });\n\n            const operation = camelcase(resource);\n\n            let query, queryVariables;\n\n            if (meta?.fields) {\n                const gqlQuery = gql.query({\n                    operation,\n                    fields: [{ nodes: meta?.fields || [\"id\"] }],\n                    variables: {\n                        filter: {\n                            type: camelcase(`${singular(resource)}Filter`, {\n                                pascalCase: true,\n                            }),\n                            required: true,\n                            value: {\n                                id: { in: ids },\n                            },\n                        },\n                    },\n                });\n                query = gqlQuery.query;\n                queryVariables = gqlQuery.variables;\n            } else {\n                query = gqlTag`\n                    query GetMany${pascalResource}($filter: ${singular(\n                    pascalResource,\n                )}Filter!) {\n                        ${operation}(filter: $filter) {\n                            nodes {\n                                id\n                            }\n                        }\n                    }\n                `;\n\n                queryVariables = {\n                    filter: { id: { in: ids } },\n                };\n            }\n\n            const response = await client.request<BaseRecord>(\n                query,\n                queryVariables,\n            );\n\n            return {\n                data: response[operation].nodes,\n            };\n        },\n        getOne: async ({ resource, id, meta }) => {\n            const operation = camelcase(singular(resource));\n\n            const gqlOperation = meta?.gqlQuery ?? meta?.gqlMutation;\n\n            if (gqlOperation) {\n                let query = gqlOperation;\n                const variables = { id };\n\n                if (isMutation(gqlOperation)) {\n                    const stringFields = getOperationFields(gqlOperation);\n\n                    query = gqlTag`\n                        query Get${camelcase(singular(resource), {\n                            pascalCase: true,\n                        })}($id: ID!) {\n                            ${operation}(id: $id) {\n                            ${stringFields}\n                            }\n                        }\n                    `;\n                }\n\n                const response = await client.request<BaseRecord>(\n                    query,\n                    variables,\n                );\n\n                return {\n                    data: response[operation],\n                };\n            }\n\n            const { query, variables } = gql.query({\n                operation,\n                fields: meta?.fields || [\"id\"],\n                variables: {\n                    id: {\n                        type: \"ID\",\n                        required: true,\n                        value: id,\n                    },\n                },\n            });\n\n            const response = await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: response[operation],\n            };\n        },\n        deleteOne: async ({ resource, id, meta }) => {\n            const pascalResource = camelcase(singular(resource), {\n                pascalCase: true,\n            });\n\n            const operation = `deleteOne${pascalResource}`;\n\n            if (meta?.gqlMutation) {\n                const response = await client.request<BaseRecord>(\n                    meta.gqlMutation,\n                    { input: { id } },\n                );\n\n                return {\n                    data: response[operation],\n                };\n            }\n\n            const query = gqlTag`\n                    mutation DeleteOne${pascalResource}($input: DeleteOne${pascalResource}Input!) {\n                        ${operation}(input: $input) {\n                            id\n                        }\n                    }\n                `;\n\n            const response = await client.request<BaseRecord>(query, {\n                input: { id },\n            });\n\n            return {\n                data: response[operation],\n            };\n        },\n        deleteMany: async ({ resource, ids }) => {\n            const pascalResource = camelcase(resource, {\n                pascalCase: true,\n            });\n            const operation = `deleteMany${pascalResource}`;\n\n            const query = gqlTag`\n                mutation DeleteMany${pascalResource}($input: DeleteMany${pascalResource}Input!) {\n                    ${operation}(input: $input) {\n                        deletedCount\n                    }\n                }\n            `;\n\n            const variables = {\n                input: {\n                    filter: {\n                        id: { in: ids },\n                    },\n                },\n            };\n\n            await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: [],\n            };\n        },\n        getApiUrl: () => {\n            throw Error(\n                \"Not implemented on refine-nestjs-query data provider.\",\n            );\n        },\n        custom: async ({ url, method, headers, meta }) => {\n            if (url) {\n                client.setEndpoint(url);\n            }\n\n            if (headers) {\n                client.setHeaders(headers);\n            }\n\n            const gqlOperation = meta?.gqlMutation ?? meta?.gqlQuery;\n\n            if (gqlOperation) {\n                const response: any = await client.request(\n                    gqlOperation,\n                    meta?.variables ?? {},\n                );\n\n                return { data: response };\n            }\n\n            if (meta?.rawQuery) {\n                const response = await client.request<BaseRecord>(\n                    meta.rawQuery,\n                    meta.variables,\n                );\n\n                return { data: response };\n            }\n\n            if (meta) {\n                if (meta.operation) {\n                    let query, variables;\n\n                    if (method === \"get\") {\n                        const gqlQuery = gql.query({\n                            operation: meta.operation,\n                            fields: meta.fields,\n                            variables: meta.variables,\n                        });\n\n                        query = gqlQuery.query;\n                        variables = gqlQuery.variables;\n                    } else {\n                        const gqlMutation = gql.mutation({\n                            operation: meta.operation,\n                            fields: meta.fields,\n                            variables: meta.variables,\n                        });\n\n                        query = gqlMutation.query;\n                        variables = gqlMutation.variables;\n                    }\n\n                    const response = await client.request<BaseRecord>(\n                        query,\n                        variables,\n                    );\n\n                    return {\n                        data: response[meta.operation],\n                    };\n                } else {\n                    throw Error(\"GraphQL operation name required.\");\n                }\n            } else {\n                throw Error(\n                    \"GraphQL needs operation, fields and variables values in meta object.\",\n                );\n            }\n        },\n    };\n};\n\nexport default dataProvider;\n","import {\n    CrudFilter,\n    CrudOperators,\n    CrudSorting,\n    LogicalFilter,\n    Pagination,\n} from \"@refinedev/core\";\n\nimport camelcase from \"camelcase\";\nimport * as gql from \"gql-query-builder\";\nimport VariableOptions from \"gql-query-builder/build/VariableOptions\";\nimport { Client } from \"graphql-ws\";\nimport set from \"lodash/set\";\nimport { singular } from \"pluralize\";\n\nimport { getOperationFields } from \"./graphql\";\n\nexport const generateSubscription = (\n    client: Client,\n    { callback, params, meta }: any,\n    type: string,\n) => {\n    const generatorMap: any = {\n        created: generateCreatedSubscription,\n        updated: generateUpdatedSubscription,\n        deleted: generateDeletedSubscription,\n    };\n\n    const { resource, filters, subscriptionType, id, ids } = params ?? {};\n\n    const generator = generatorMap[type];\n\n    const { operation, query, variables, operationName } = generator({\n        ids,\n        id,\n        resource,\n        filters,\n        meta,\n        subscriptionType,\n    });\n\n    const onNext = (payload: any) => {\n        callback(payload.data[operation]);\n    };\n\n    const unsubscribe = client.subscribe(\n        { query, variables, operationName },\n        {\n            next: onNext,\n            error: console.error,\n            complete: () => null,\n        },\n    );\n\n    return unsubscribe;\n};\n\nconst operatorMap: { [key: string]: string } = {\n    eq: \"eq\",\n    ne: \"neq\",\n    lt: \"lt\",\n    gt: \"gt\",\n    lte: \"lte\",\n    gte: \"gte\",\n    in: \"in\",\n    nin: \"notIn\",\n};\n\nconst operatorMapper = (\n    operator: CrudOperators,\n    value: any,\n): { [key: string]: any } => {\n    if (operator === \"contains\") {\n        return { iLike: `%${value}%` };\n    }\n\n    if (operator === \"ncontains\") {\n        return { notILike: `%${value}%` };\n    }\n\n    if (operator === \"startswith\") {\n        return { iLike: `${value}%` };\n    }\n\n    if (operator === \"nstartswith\") {\n        return { notILike: `${value}%` };\n    }\n\n    if (operator === \"endswith\") {\n        return { iLike: `%${value}` };\n    }\n\n    if (operator === \"nendswith\") {\n        return { notILike: `%${value}` };\n    }\n\n    if (operator === \"null\") {\n        return { is: null };\n    }\n\n    if (operator === \"nnull\") {\n        return { isNot: null };\n    }\n\n    if (operator === \"between\") {\n        if (!Array.isArray(value)) {\n            throw new Error(\"Between operator requires an array\");\n        }\n\n        if (value.length !== 2) {\n            return {};\n        }\n\n        return { between: { lower: value[0], upper: value[1] } };\n    }\n\n    return { [operatorMap[operator]]: value };\n};\n\nexport const generateFilters = (filters: LogicalFilter[]) => {\n    const result: { [key: string]: { [key: string]: string | number } } = {};\n\n    filters\n        .filter((f) => {\n            if (Array.isArray(f.value) && f.value.length === 0) {\n                return false;\n            }\n\n            return !!f.value;\n        })\n        .map((filter: LogicalFilter | CrudFilter) => {\n            if (filter.operator === \"and\" || filter.operator === \"or\") {\n                return set(result, filter.operator, [\n                    generateFilters(filter.value as LogicalFilter[]),\n                ]);\n            } else if (\"field\" in filter) {\n                return set(\n                    result,\n                    filter.field,\n                    operatorMapper(filter.operator, filter.value),\n                );\n            } else {\n                return {};\n            }\n        });\n\n    return result;\n};\n\nexport const generateSorting = (sorters: CrudSorting) => {\n    return sorters.map((sorter) => {\n        return {\n            field: sorter.field,\n            direction: sorter.order.toUpperCase(),\n        };\n    });\n};\n\nexport const generatePaging = (pagination: Pagination) => {\n    // maximum value of 32 bit signed integer\n    if (pagination.mode === \"off\") return { limit: 2147483647 };\n\n    if (pagination.mode !== \"server\") return undefined;\n\n    if (!pagination.current || !pagination.pageSize) return undefined;\n\n    return {\n        limit: pagination.pageSize,\n        offset: (pagination.current - 1) * pagination.pageSize,\n    };\n};\n\nexport const generateCreatedSubscription = ({\n    resource,\n    filters,\n    meta,\n}: any) => {\n    const gqlOperation = meta?.gqlQuery ?? meta?.gqlMutation;\n\n    if (gqlOperation) {\n        const singularResourceName = camelcase(singular(resource), {\n            pascalCase: true,\n        });\n\n        const operationName = `Created${singularResourceName}`;\n\n        const operation = `created${singularResourceName}`;\n\n        const query = `\n            subscription ${operationName}($input: Create${singularResourceName}SubscriptionFilterInput) {\n                ${operation}(input: $input) {\n                    ${getOperationFields(gqlOperation)}\n                }\n            }\n        `;\n\n        const variables: VariableOptions = {};\n\n        if (filters) {\n            variables[\"input\"] = {\n                filter: generateFilters(\n                    filters.filter(\n                        (filter: LogicalFilter) => !filter.field.includes(\".\"),\n                    ),\n                ),\n            };\n        }\n\n        return { query, variables, operation, operationName };\n    }\n\n    const operation = `created${camelcase(singular(resource), {\n        pascalCase: true,\n    })}`;\n\n    const queryVariables: VariableOptions = {};\n\n    if (filters) {\n        queryVariables[\"input\"] = {\n            type: camelcase(\n                `create_${singular(resource)}_subscription_filter_input`,\n                {\n                    pascalCase: true,\n                },\n            ),\n            required: true,\n            value: {\n                filter: generateFilters(\n                    filters.filter(\n                        (filter: LogicalFilter) => !filter.field.includes(\".\"),\n                    ),\n                ),\n            },\n        };\n    }\n\n    const { query, variables } = gql.subscription({\n        operation,\n        fields: meta.fields,\n        variables: queryVariables,\n    });\n\n    return { query, variables, operation };\n};\n\nexport const generateUpdatedSubscription = ({\n    id,\n    resource,\n    filters,\n    meta,\n}: any) => {\n    const gqlOperation = meta?.gqlQuery ?? meta?.gqlMutation;\n\n    if (gqlOperation) {\n        const singularResourceName = camelcase(singular(resource), {\n            pascalCase: true,\n        });\n\n        const operationName = `Updated${singularResourceName}`;\n\n        const operation = `updatedOne${singularResourceName}`;\n\n        const query = `\n            subscription ${operationName}($input: UpdateOne${singularResourceName}SubscriptionFilterInput) {\n                ${operation}(input: $input) {\n                   ${getOperationFields(gqlOperation)}\n                }\n            }\n        `;\n\n        const variables: VariableOptions = {};\n\n        if (filters) {\n            variables[\"input\"] = {\n                filter: generateFilters(\n                    filters.filter(\n                        (filter: LogicalFilter) => !filter.field.includes(\".\"),\n                    ),\n                ),\n            };\n        }\n\n        if (id) {\n            variables[\"input\"] = {\n                filter: {\n                    id: { eq: id },\n                },\n            };\n        }\n\n        return { query, variables, operation, operationName };\n    }\n\n    const operation = `updatedOne${camelcase(singular(resource), {\n        pascalCase: true,\n    })}`;\n\n    const queryVariables: VariableOptions = {};\n\n    if (filters) {\n        queryVariables[\"input\"] = {\n            type: camelcase(\n                `update_one_${singular(resource)}_subscription_filter_input`,\n                {\n                    pascalCase: true,\n                },\n            ),\n            required: true,\n            value: {\n                filter: generateFilters(\n                    filters.filter(\n                        (filter: LogicalFilter) => !filter.field.includes(\".\"),\n                    ),\n                ),\n            },\n        };\n    }\n\n    if (id) {\n        queryVariables[\"input\"] = {\n            type: camelcase(\n                `update_one_${singular(resource)}_subscription_filter_input`,\n                {\n                    pascalCase: true,\n                },\n            ),\n            required: true,\n            value: {\n                filter: {\n                    id: { eq: id },\n                },\n            },\n        };\n    }\n\n    const { query, variables } = gql.subscription({\n        operation,\n        fields: meta.fields,\n        variables: queryVariables,\n    });\n\n    return { query, variables, operation };\n};\n\nexport const generateDeletedSubscription = ({\n    resource,\n    filters,\n    meta,\n}: any) => {\n    if (meta?.gqlQuery) {\n        const singularResourceName = camelcase(singular(resource), {\n            pascalCase: true,\n        });\n\n        const operationName = `Deleted${singularResourceName}`;\n\n        const operation = `deletedOne${singularResourceName}`;\n\n        const query = `\n            subscription ${operationName}($input: DeleteOne${singularResourceName}SubscriptionFilterInput) {\n                ${operation}(input: $input) {\n                    id\n                }\n            }\n        `;\n\n        const variables: VariableOptions = {};\n\n        if (filters) {\n            variables[\"input\"] = {\n                filter: generateFilters(\n                    filters.filter(\n                        (filter: LogicalFilter) => !filter.field.includes(\".\"),\n                    ),\n                ),\n            };\n        }\n\n        return { query, variables, operation, operationName };\n    }\n\n    const operation = `deletedOne${camelcase(singular(resource), {\n        pascalCase: true,\n    })}`;\n\n    const queryVariables: VariableOptions = {};\n\n    if (filters) {\n        queryVariables[\"input\"] = {\n            type: camelcase(\n                `delete_one_${singular(resource)}_subscription_filter_input`,\n                {\n                    pascalCase: true,\n                },\n            ),\n            required: true,\n            value: {\n                filter: generateFilters(\n                    filters.filter(\n                        (filter: LogicalFilter) => !filter.field.includes(\".\"),\n                    ),\n                ),\n            },\n        };\n    }\n\n    const { query, variables } = gql.subscription({\n        operation,\n        fields: meta.fields.filter(\n            (field: string | object) => typeof field !== \"object\",\n        ),\n        variables: queryVariables,\n    });\n\n    return { query, variables, operation };\n};\n","import { FieldNode, DocumentNode, visit, SelectionSetNode } from \"graphql\";\n\nconst getChildNodesField = (node: FieldNode): FieldNode | undefined => {\n    return node?.selectionSet?.selections?.find(\n        (node) => node.kind === \"Field\" && node.name.value === \"nodes\",\n    ) as FieldNode;\n};\n\nexport const getOperationFields = (documentNode: DocumentNode) => {\n    const fieldLines: string[] = [];\n    let isInitialEnter = true;\n    let depth = 0;\n    let isNestedField = false;\n\n    visit(documentNode, {\n        Field: {\n            enter(node): SelectionSetNode | void {\n                if (isInitialEnter) {\n                    isInitialEnter = false;\n\n                    const childNodesField = getChildNodesField(node);\n\n                    const nodeToReturn = childNodesField ?? node;\n\n                    if (typeof nodeToReturn.selectionSet === \"undefined\") {\n                        throw new Error(\"Operation must have a selection set\");\n                    }\n\n                    return nodeToReturn.selectionSet;\n                }\n\n                fieldLines.push(\n                    `${\n                        depth > 0\n                            ? \"  \".repeat(isNestedField ? depth : depth - 1)\n                            : \"\"\n                    }${node.name.value}${node.selectionSet ? \" {\" : \"\"}`,\n                );\n\n                if (node.selectionSet) {\n                    depth++;\n                    isNestedField = true;\n                }\n            },\n            leave(node) {\n                if (node.selectionSet) {\n                    depth--;\n                    fieldLines.push(`${\"  \".repeat(depth)}}`);\n                    isNestedField = false;\n                }\n            },\n        },\n    });\n\n    return fieldLines.join(\"\\n\").trim();\n};\n\nexport const isMutation = (documentNode: DocumentNode) => {\n    let isMutation = false;\n\n    visit(documentNode, {\n        OperationDefinition: {\n            enter(node) {\n                if (node.operation === \"mutation\") {\n                    isMutation = true;\n                }\n            },\n        },\n    });\n\n    return isMutation;\n};\n","import { LiveProvider } from \"@refinedev/core\";\n\nimport { Client } from \"graphql-ws\";\n\nimport { generateSubscription } from \"../utils\";\n\ntype SubscriptionAction = \"created\" | \"updated\" | \"deleted\";\n\nexport const liveProvider = (client: Client): LiveProvider => {\n    const subscribeToResource = (\n        client: Client,\n        callback: Function,\n        params: any,\n        meta: any,\n        action: SubscriptionAction,\n        resource: string,\n        unsubscribes: Function[],\n    ) => {\n        const unsubscribe = generateSubscription(\n            client,\n            { callback, params, meta },\n            action,\n        );\n        unsubscribes.push(unsubscribe);\n    };\n\n    return {\n        subscribe({ callback, params, meta }) {\n            const { resource, subscriptionType } = params ?? {};\n\n            if (!meta || !subscriptionType || !resource) {\n                throw new Error(\n                    \"[useSubscription]: `meta`, `subscriptionType` and `resource` are required in `params` for graphql subscriptions\",\n                );\n            }\n\n            const unsubscribes: any[] = [];\n\n            if (params?.subscriptionType === \"useList\") {\n                [\"created\", \"updated\", \"deleted\"].forEach((action) =>\n                    subscribeToResource(\n                        client,\n                        callback,\n                        params,\n                        meta,\n                        action as SubscriptionAction,\n                        resource,\n                        unsubscribes,\n                    ),\n                );\n            }\n\n            if (params?.subscriptionType === \"useOne\") {\n                subscribeToResource(\n                    client,\n                    callback,\n                    params,\n                    meta,\n                    \"updated\",\n                    resource,\n                    unsubscribes,\n                );\n            }\n\n            const unsubscribe = () => {\n                unsubscribes.forEach((unsubscribe) => unsubscribe());\n            };\n\n            return unsubscribe;\n        },\n        unsubscribe(unsubscribe) {\n            unsubscribe();\n        },\n    };\n};\n","import dataProvider from \"./dataProvider\";\n\nexport * from \"./dataProvider\";\nexport * from \"./interfaces\";\nexport * from \"./liveProvider\";\nexport * as qqlQueryBuilder from \"gql-query-builder\";\nexport type {\n    BatchRequestDocument,\n    BatchRequestsExtendedOptions,\n    BatchRequestsOptions,\n    ClientError,\n    GraphQLWebSocketClient,\n    RawRequestExtendedOptions,\n    RawRequestOptions,\n    RequestDocument,\n    RequestExtendedOptions,\n    RequestOptions,\n    Variables,\n} from \"graphql-request\";\nexport {\n    batchRequests,\n    gql,\n    GraphQLClient,\n    rawRequest,\n    request,\n    resolveRequestDocument,\n} from \"graphql-request\";\nexport * as graphqlWS from \"graphql-ws\";\n\nexport default dataProvider;\n","import createRequestBody from './createRequestBody.js'\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport { HeadersInstanceToPlainObject, uppercase } from './helpers.js'\nimport {\n  parseBatchRequestArgs,\n  parseRawRequestArgs,\n  parseRawRequestExtendedArgs,\n  parseRequestArgs,\n  parseRequestExtendedArgs,\n} from './parseArgs.js'\nimport { resolveRequestDocument } from './resolveRequestDocument.js'\nimport type * as Dom from './types.dom.js'\nimport type {\n  HTTPMethodInput,\n  MaybeFunction,\n  RequestConfig,\n  RequestMiddleware,\n  Response,\n  VariablesAndRequestHeadersArgs,\n} from './types.js'\nimport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n} from './types.js'\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport crossFetch, * as CrossFetch from 'cross-fetch'\nimport type { T, V } from 'vitest/dist/types-7cd96283.js'\n\nexport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n}\n\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = (headers: Dom.RequestInit['headers']): Record<string, string> => {\n  let oHeaders: Record<string, string> = {}\n  if (headers) {\n    if (\n      (typeof Headers !== `undefined` && headers instanceof Headers) ||\n      (CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers)\n    ) {\n      oHeaders = HeadersInstanceToPlainObject(headers)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(([name, value]) => {\n        if (name && value !== undefined) {\n          oHeaders[name] = value\n        }\n      })\n    } else {\n      oHeaders = headers as Record<string, string>\n    }\n  }\n\n  return oHeaders\n}\n\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = (str: string): string => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim()\n\ntype BuildRequestConfigParamsBatch<V> = {\n  query: string[]\n  variables: V[] | undefined\n  operationName: undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParamsSingle<V> = {\n  query: string\n  variables: V | undefined\n  operationName: string | undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParams<V> = BuildRequestConfigParamsSingle<V> | BuildRequestConfigParamsBatch<V>\n\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = <V extends Variables>(params: BuildRequestConfigParams<V>): string => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params as BuildRequestConfigParamsSingle<V>\n    const search: string[] = [`query=${encodeURIComponent(cleanQuery(params_.query))}`]\n\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`)\n    }\n\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`)\n    }\n\n    return search.join(`&`)\n  }\n\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`)\n  }\n\n  // Batch support\n  const params_ = params as BuildRequestConfigParamsBatch<V>\n  const payload = params.query.reduce<{ query: string; variables: string | undefined }[]>(\n    (acc, currentQuery, index) => {\n      acc.push({\n        query: cleanQuery(currentQuery),\n        variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined,\n      })\n      return acc\n    },\n    []\n  )\n\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`\n}\n\ntype Fetch = (url: string, config: Dom.RequestInit) => Promise<Dom.Response>\n\ninterface RequestVerbParams<V extends Variables = Variables> {\n  url: string\n  query: string | string[]\n  fetch: Fetch\n  fetchOptions: Dom.RequestInit\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  middleware?: RequestMiddleware<V>\n}\n\nconst createHttpMethodFetcher =\n  (method: 'GET' | 'POST') =>\n  async <V extends Variables>(params: RequestVerbParams<V>) => {\n    const { url, query, variables, operationName, fetch, fetchOptions, middleware } = params\n\n    const headers = { ...params.headers }\n    let queryParams = ``\n    let body = undefined\n\n    if (method === `POST`) {\n      body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer)\n      if (typeof body === `string`) {\n        // @ts-expect-error todo\n        headers[`Content-Type`] = `application/json`\n      }\n    } else {\n      // @ts-expect-error todo needs ADT for TS to understand the different states\n      queryParams = buildRequestConfig<V>({\n        query,\n        variables,\n        operationName,\n        jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n      })\n    }\n\n    const init: Dom.RequestInit = {\n      method,\n      headers,\n      body,\n      ...fetchOptions,\n    }\n\n    let urlResolved = url\n    let initResolved = init\n    if (middleware) {\n      const result = await Promise.resolve(middleware({ ...init, url, operationName, variables }))\n      const { url: urlNew, ...initNew } = result\n      urlResolved = urlNew\n      initResolved = initNew\n    }\n    if (queryParams) {\n      urlResolved = `${urlResolved}?${queryParams}`\n    }\n    return await fetch(urlResolved, initResolved)\n  }\n\n/**\n * GraphQL Client.\n */\nexport class GraphQLClient {\n  constructor(private url: string, public readonly requestConfig: RequestConfig = {}) {}\n\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest: RawRequestMethod = async <T, V extends Variables = Variables>(\n    ...args: RawRequestMethodArgs<V>\n  ): Promise<Response<T>> => {\n    const [queryOrOptions, variables, requestHeaders] = args\n    const rawRequestOptions = parseRawRequestArgs<V>(queryOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal\n    }\n\n    const { operationName } = resolveRequestDocument(rawRequestOptions.query)\n\n    return makeRequest<T, V>({\n      url,\n      query: rawRequestOptions.query,\n      variables: rawRequestOptions.variables as V,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(rawRequestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send a GraphQL document to the server.\n   */\n  async request<T, V extends Variables = Variables>(\n    document: RequestDocument | TypedDocumentNode<T, V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T>\n  async request<T, V extends Variables = Variables>(options: RequestOptions<V, T>): Promise<T>\n  async request<T, V extends Variables = Variables>(\n    documentOrOptions: RequestDocument | TypedDocumentNode<T, V> | RequestOptions<V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T> {\n    const [variables, requestHeaders] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal\n    }\n\n    const { query, operationName } = resolveRequestDocument(requestOptions.document)\n\n    return makeRequest<T>({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send GraphQL documents in batch to the server.\n   */\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsOptions<V>): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(\n    documentsOrOptions: BatchRequestDocument<V>[] | BatchRequestsOptions<V>,\n    requestHeaders?: Dom.RequestInit['headers']\n  ): Promise<T> {\n    const batchRequestOptions = parseBatchRequestArgs<V>(documentsOrOptions, requestHeaders)\n    const { headers, ...fetchOptions } = this.requestConfig\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal\n    }\n\n    const queries = batchRequestOptions.documents.map(\n      ({ document }) => resolveRequestDocument(document).query\n    )\n    const variables = batchRequestOptions.documents.map(({ variables }) => variables)\n\n    return makeRequest<T>({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders),\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? crossFetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware,\n    })\n      .then((response) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  setHeaders(headers: Dom.RequestInit['headers']): GraphQLClient {\n    this.requestConfig.headers = headers\n    return this\n  }\n\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key: string, value: string): GraphQLClient {\n    const { headers } = this.requestConfig\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-ignore\n      headers[key] = value\n    } else {\n      this.requestConfig.headers = { [key]: value }\n    }\n\n    return this\n  }\n\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value: string): GraphQLClient {\n    this.url = value\n    return this\n  }\n}\n\nconst makeRequest = async <T = unknown, V extends Variables = Variables>(params: {\n  url: string\n  query: string | string[]\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  fetch: Fetch\n  method?: HTTPMethodInput\n  fetchOptions: Dom.RequestInit\n  middleware?: RequestMiddleware<V>\n}): Promise<Response<T>> => {\n  const { query, variables, fetchOptions } = params\n  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`))\n  const isBatchingQuery = Array.isArray(params.query)\n  const response = await fetcher(params)\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer)\n\n  const successfullyReceivedData = Array.isArray(result)\n    ? !result.some(({ data }) => !data)\n    : Boolean(result.data)\n\n  const successfullyPassedErrorPolicy =\n    Array.isArray(result) ||\n    !result.errors ||\n    (Array.isArray(result.errors) && !result.errors.length) ||\n    fetchOptions.errorPolicy === `all` ||\n    fetchOptions.errorPolicy === `ignore`\n\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const { errors, ...rest } = Array.isArray(result) ? result : result\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result\n    const dataEnvelope = isBatchingQuery ? { data } : data\n\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status,\n    }\n  } else {\n    const errorResult =\n      typeof result === `string`\n        ? {\n            error: result,\n          }\n        : result\n    throw new ClientError(\n      // @ts-expect-error TODO\n      { ...errorResult, status: response.status, headers: response.headers },\n      { query, variables }\n    )\n  }\n}\n\n// prettier-ignore\ninterface RawRequestMethod {\n  <T, V extends Variables = Variables>(query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestMethodArgs<V extends Variables> =\n  | [query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']]\n  | [RawRequestOptions<V>]\n\n// prettier-ignore\ninterface RawRequest {\n  <T, V extends Variables = Variables>(url: string, query: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestExtendedOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestArgs<V extends Variables> = \n  | [options: RawRequestExtendedOptions<V>, query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n  | [url: string,                           query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nexport const rawRequest: RawRequest = async <T, V extends Variables>(\n  ...args: RawRequestArgs<V>\n): Promise<Response<T>> => {\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args\n  const requestOptions = parseRawRequestExtendedArgs<V>(urlOrOptions, query, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.rawRequest<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await request('https://foo.bar/graphql', `\n *   {\n *     query {\n *       users\n *     }\n *   }\n * `)\n *\n * // You can also pass a GraphQL DocumentNode. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * // If you don't actually care about using DocumentNode but just\n * // want the tooling support for gql template tag like IDE syntax\n * // coloring and prettier autoformat then note you can use the\n * // passthrough gql tag shipped with graphql-request to save a bit\n * // of performance and not have to install another dep into your project.\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n */\nexport async function request<T, V extends Variables = Variables>(\n  url: string,\n  // @ts-ignore\n  document: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  options: RequestExtendedOptions<V, T>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  urlOrOptions: string | RequestExtendedOptions<V, T>,\n  // @ts-ignore\n  document?: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T> {\n  // @ts-ignore\n  const requestOptions = parseRequestExtendedArgs<V>(urlOrOptions, document, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.request<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nexport const batchRequests: BatchRequests = async (...args: BatchRequestsArgs) => {\n  const params = parseBatchRequestsArgsExtended(args)\n  const client = new GraphQLClient(params.url)\n  return client.batchRequests(params)\n}\n\ninterface Result<Data extends object = object> {\n  data: Data\n}\n\ntype BatchResult = [Result, ...Result[]]\n\n// prettier-ignore\ninterface BatchRequests {\n  <T extends BatchResult, V extends Variables = Variables>(url: string, documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  <T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsExtendedOptions<V>): Promise<T>\n}\n\ntype BatchRequestsArgs =\n  | [url: string, documents: BatchRequestDocument[], requestHeaders?: Dom.RequestInit['headers']]\n  | [options: BatchRequestsExtendedOptions]\n\nconst parseBatchRequestsArgsExtended = (args: BatchRequestsArgs): BatchRequestsExtendedOptions => {\n  if (args.length === 1) {\n    return args[0]\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined,\n    }\n  }\n}\n\nexport default request\n\nconst getResult = async (\n  response: Dom.Response,\n  jsonSerializer: Dom.JsonSerializer\n): Promise<\n  | { data: object; errors: undefined }[]\n  | { data: object; errors: undefined }\n  | { data: undefined; errors: object }\n  | { data: undefined; errors: object[] }\n> => {\n  let contentType: string | undefined\n\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value\n    }\n  })\n\n  if (\n    contentType &&\n    (contentType.toLowerCase().startsWith(`application/json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql+json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql-response+json`))\n  ) {\n    return jsonSerializer.parse(await response.text()) as any\n  } else {\n    return response.text() as any\n  }\n}\n\nconst callOrIdentity = <T>(value: MaybeFunction<T>) => {\n  return typeof value === `function` ? (value as () => T)() : value\n}\n\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nexport const gql = (chunks: TemplateStringsArray, ...variables: any[]): string => {\n  return chunks.reduce(\n    (accumulator, chunk, index) => `${accumulator}${chunk}${index in variables ? variables[index] : ``}`,\n    ``\n  )\n}\n\nexport { GraphQLWebSocketClient } from './graphql-ws.js'\nexport { resolveRequestDocument } from './resolveRequestDocument.js'\n"],"mappings":"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","names":["import_camelcase","gql","import_graphql_tag","import_pluralize","import_camelcase","gql","import_set","import_pluralize","import_graphql","getChildNodesField","node","_a","_b","getOperationFields","documentNode","fieldLines","isInitialEnter","depth","isNestedField","nodeToReturn","isMutation","generateSubscription","client","callback","params","meta","type","generatorMap","generateCreatedSubscription","generateUpdatedSubscription","generateDeletedSubscription","resource","filters","subscriptionType","id","ids","generator","operation","query","variables","operationName","onNext","payload","operatorMap","operatorMapper","operator","value","generateFilters","result","f","filter","set","generateSorting","sorters","sorter","generatePaging","pagination","gqlOperation","singularResourceName","camelcase","getOperationFields","queryVariables","field","dataProvider","client","resource","pagination","sorters","filters","meta","operation","camelcase","paging","generatePaging","queryVariables","query","variables","generateFilters","generateSorting","gqlQuery","response","ids","gqlOperation","id","pascalResource","mutationOperation","mutation","gqlTag","isMutation","stringFields","getOperationFields","url","method","headers","gqlMutation","dataProvider_default","liveProvider","client","subscribeToResource","callback","params","meta","action","resource","unsubscribes","unsubscribe","generateSubscription","subscriptionType","qqlQueryBuilder","import_createRequestBody","import_defaultJsonSerializer","import_helpers","import_parseArgs","import_resolveRequestDocument","import_types","CrossFetch","import_graphql_ws","resolveHeaders","headers","oHeaders","CrossFetch","name","value","cleanQuery","str","buildRequestConfig","params","params_","search","payload","acc","currentQuery","index","createHttpMethodFetcher","method","url","query","variables","operationName","fetch","fetchOptions","middleware","queryParams","body","createRequestBody","init","urlResolved","initResolved","result","urlNew","initNew","GraphQLClient","requestConfig","args","queryOrOptions","requestHeaders","rawRequestOptions","crossFetch","requestMiddleware","responseMiddleware","makeRequest","callOrIdentity","response","error","documentOrOptions","variablesAndRequestHeaders","requestOptions","documentsOrOptions","batchRequestOptions","queries","document","key","fetcher","isBatchingQuery","getResult","successfullyReceivedData","data","successfullyPassedErrorPolicy","errors","rest","errorResult","rawRequest","urlOrOptions","request","batchRequests","parseBatchRequestsArgsExtended","getResult","response","jsonSerializer","contentType","value","key","callOrIdentity","gql","chunks","variables","accumulator","chunk","index","graphqlWS","src_default","dataProvider_default"]}